% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confint.R
\name{confint.egf}
\alias{confint.egf}
\title{Confidence intervals on fitted values}
\usage{
\method{confint}{egf}(
  object,
  parm,
  level = 0.95,
  top = egf_get_names_top(object, link = TRUE),
  link = TRUE,
  method = c("wald", "profile", "uniroot"),
  parallel = egf_parallel(),
  trace = FALSE,
  grid_len = 12,
  interval_scale = 7,
  breaks = NULL,
  probs = NULL,
  subset = NULL,
  append = NULL,
  .subset = NULL,
  .append = NULL,
  ...
)
}
\arguments{
\item{object}{An \code{"\link{egf}"} object.}

\item{parm}{Unused argument included for generic consistency.}

\item{level}{A number in the interval (0,1) indicating a confidence level.}

\item{top}{A subset of \code{\link{egf_get_names_top}(object, link = TRUE)}
naming top level nonlinear model parameters for which confidence
intervals should be computed. If \code{object$model$curve} is
\code{"exponential"}, \code{"logistic"}, or \code{"richards"},
then \code{top} may also contain \code{"tdoubling"} and \code{"R0"}.}

\item{link}{A logical flag. If \code{FALSE}, then confidence intervals
on inverse link-transformed fitted values are computed.}

\item{method}{A \link{character} string indicating how confidence intervals
should be computed.}

\item{parallel}{(For \code{method = "profile"} or \code{"uniroot"}.)
An \code{"\link{egf_parallel}"} object defining options for \R level
parallelization.}

\item{trace}{(For \code{method = "profile"} or \code{"uniroot"}.)
A logical flag.
If \code{TRUE}, then basic tracing messages indicating progress
are printed.
Depending on \code{object$control$trace}, these may be mixed with
optimizer output.}

\item{grid_len}{(For \code{method = "profile"}.)
A positive integer. Step sizes chosen adaptively by
\code{\link[TMB]{tmbprofile}} will generate approximately
this many points on each side of a profile's minimum point.}

\item{interval_scale}{(For \code{method = "uniroot"}.)
A positive number.
\code{\link[TMB]{tmbroot}} will search for roots in the interval
of width \code{interval_scale * se} centered at \code{estimate},
where \code{estimate} is the fitted value (link scale)
and \code{se} is the corresponding standard error.}

\item{breaks, probs}{(For \code{top = "R0"}.)
Arguments to \code{\link{compute_R0}}.}

\item{subset}{An expression to be evaluated in
\code{\link[=model.frame.egf]{model.frame}(object, "combined")}.
It must evaluate to a valid index vector for the rows of
the data frame and, in turn, fitting windows.
Confidence intervals are computed only for indexed windows.
The default (\code{NULL}) is to consider all windows.}

\item{append}{An expression indicating variables in
\code{\link[=model.frame.egf]{model.frame}(object, "combined")}
to be included with the result.
The default (\code{NULL}) is to append nothing.}

\item{.subset, .append}{Index vectors to be used (if non-\code{NULL}) in place of
the result of evaluating \code{subset} and \code{append}.}

\item{...}{Unused optional arguments.}
}
\value{
A data frame inheriting from class \code{"egf_confint"}, with variables:
\item{top}{
  Top level nonlinear model parameter,
  from \code{\link{egf_get_names_top}(object, link = TRUE)}.
}
\item{ts}{
  Time series, from
  \code{\link{levels}(\link[=model.frame.egf]{model.frame}(object)$ts)}.
}
\item{window}{
  Fitting window, from
  \code{\link{levels}(\link[=model.frame.egf]{model.frame}(object)$window)}.
}
\item{estimate, lower, upper}{
  Fitted value and approximate lower and upper confidence limits.
}
\code{level} and
\code{frame_windows = \link[=model.frame.egf]{model.frame}(object, "windows")}
are retained as attributes.
}
\description{
Computes confidence intervals on fitted values of top level nonlinear
model parameters and, where appropriate, initial doubling times and
basic reproduction numbers.
}
\details{
Three methods are provided for calculating confidence intervals:
\describe{
\item{\code{wald}}{
  See \code{\link{confint.egf_fitted}}.
}
\item{\code{profile}}{
  See \code{\link{confint.egf_profile}}.
}
\item{\code{uniroot}}{
  Similar to \code{"profile"}, except that the two solutions
  of \code{deviance(value) = \link{qchisq}(level, df = 1)} are
  approximated by root-finding using \code{\link[TMB]{tmbroot}}
  (\code{\link{uniroot}} internally).
}
}
For top level parameters following random effects models,
\code{"wald"} returns confidence intervals on individual fitted values,
while \code{"profile"} and \code{"uniroot"} return confidence intervals
on population fitted values, which are the fixed effects components of
individual fitted values.

\code{"wald"} assumes, e.g., asymptotic normality of the maximum likelihood
estimator. \code{"profile"} and \code{"uniroot"} avoid these issues but are
typically more expensive, requiring estimation of many restricted models.
They are parallelized at the C++ level when there is OpenMP support and
\code{object$control$omp_num_threads} is set to an integer greater than 1.
If there is no OpenMP support, then computation can still be parallelized
at the \R level with appropriate setting of \code{parallel}.

See topic \code{\link{egf_eval}} for details on nonstandard evaluation
of \code{subset} and \code{append}.
}
\examples{
example("egf", package = "epigrowthfit", local = TRUE, echo = FALSE)
exdata <- system.file("exdata", package = "epigrowthfit", mustWork = TRUE)
object <- readRDS(file.path(exdata, "egf.rds"))

path_to_cache <- file.path(exdata, "confint-egf.rds")
if (file.exists(path_to_cache)) {
  zz <- readRDS(path_to_cache)
} else {
  zz <- confint(object)
  saveRDS(zz, file = path_to_cache)
}
str(zz)

}
\seealso{
\code{\link{plot.egf_confint}}
}
