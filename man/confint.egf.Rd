% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confint.R
\name{confint.egf}
\alias{confint.egf}
\title{Confidence intervals on fitted values}
\usage{
\method{confint}{egf}(
  object,
  parm = get_par_names(object),
  level = 0.95,
  link = TRUE,
  method = c("wald", "profile", "uniroot"),
  grid_len = 12,
  max_width = 7,
  trace = TRUE,
  parallel = c("serial", "multicore", "snow"),
  cores = getOption("egf.cores", 2L),
  outfile = NULL,
  cl = NULL,
  breaks = NULL,
  probs = NULL,
  ...
)
}
\arguments{
\item{object}{An \code{"egf"} object returned by \code{\link[=egf]{egf()}}.}

\item{parm}{A character vector giving a subset of the response variables
listed in \code{get_par_names(fitted, link = TRUE)}.
If \code{object$curve} is an element of
\code{c("exponential", "logistic", "richards")},
then \code{parm} may also contain \code{"R0"} and \code{"tdoubling"}.}

\item{level}{A number in the interval (0,1). The desired confidence level.}

\item{link}{A logical scalar. If \code{FALSE}, then confidence intervals on
inverse-link transformed fitted values are returned.}

\item{method}{A character string indicating how confidence intervals should
be calculated (see Details).}

\item{grid_len}{A positive integer. Step sizes chosen adaptively by
\code{\link[TMB:tmbprofile]{TMB::tmbprofile()}} will generate approximately this
many points on each side of the minimum point.}

\item{max_width}{A positive numeric vector, to be recycled to length \code{length(parm)}.
\code{\link[TMB:tmbroot]{TMB::tmbroot()}} will search for roots in the interval from
\code{x-max_width} to \code{x+max_width}, where \code{x} is the fitted value
(link scale) of the response variable of interest.}

\item{trace}{A logical scalar. If \code{TRUE}, then basic tracing information is
printed.}

\item{parallel}{A character string indicating a library for parallel computation.
\code{"serial"} indicates no parallelization. \code{"multicore"} forks and
is intended for use from a terminal rather than, e.g., RStudio.
On Windows, it is equivalent to \code{"serial"}. \code{"snow"} creates
socket clusters and parallelizes on both Unix-alikes and Windows.}

\item{cores}{A positive integer. The number of worker processes spawned when
\code{parallel != "serial"}. See also \code{\link[parallel:detectCores]{parallel::detectCores()}}.}

\item{outfile}{A character string containing a file path or otherwise \code{NULL}.
If a file path, then console output is diverted there. If \code{NULL},
then there is no diversion. When \code{parallel = "snow"}, diversion
may be necessary to view output.}

\item{cl}{A optional socket cluster created by
\code{\link[parallel:makeCluster]{parallel::makePSOCKcluster()}}, to be used
when \code{parallel = "snow"}. If non-\code{NULL},
then \code{cores} and \code{outfile} are ignored.}

\item{breaks, probs}{Arguments to \code{compute_R0()}, necessary if \code{"R0 \%in\% parm"}.}

\item{...}{Unused optional arguments.}
}
\value{
A data frame inheriting from class \code{"egf_confint"},
with one row per element of \code{parm} \emph{per fitting window}.

The first variable, \code{par}, is a factor whose levels are
\code{parm} (with prefixes stripped if \code{link = FALSE}). The next
\code{length(object$frame)-2} variables specify levels for each
factor in \code{object$frame[-(1:2)]} (and thus fitting windows).
The remaining variables, \code{estimate}, \code{lower}, and \code{upper},
list fitted values and the corresponding lower and upper
confidence limits.
}
\description{
Computes confidence intervals on fitted values of response variables
(see \code{\link[=fitted.egf]{fitted.egf()}}) and, where appropriate, the basic reproduction
number and initial doubling time in days.
}
\details{
Three methods are provided for calculating confidence intervals:
\describe{
\item{\code{wald}}{
Confidence limits on a fitted value (link scale) are computed as
\code{estimate + c(-1, 1) * sqrt(q) * se},
where \code{q = qchisq(level, df = 1)} and \code{estimate} and \code{se} are the
fitted value and its approximate (delta method) standard error.
}
\item{\code{profile}}{
A discrete approximation of the negative log likelihood profile
is computed using \code{\link[TMB:tmbprofile]{TMB::tmbprofile()}} then linearly interpolated
using \code{\link[TMB:confint.tmbprofile]{TMB::confint.tmbprofile()}} to approximate the two solutions
of \code{deviance(x) = qchisq(level, df = 1)}. These are the lower
and upper confidence limits on the fitted value (link scale).
See Wilks' theorem.
}
\item{\code{uniroot}}{
Similar to \code{"profile"}, except that the two solutions of
\code{deviance(x) = qchisq(level, df = 1)} are approximated
by root-finding using \code{\link[TMB:tmbroot]{TMB::tmbroot()}}. \code{\link[stats:uniroot]{stats::uniroot()}}
is called internally.
}
}
\code{"wald"} is the only method available for response variables
following a mixed (rather than fixed) effects model.

\code{"wald"} requires minimal computation time but assumes, e.g.,
asymptotic normality of the maximum likelihood estimator.
A further limitation of \code{"wald"} is functional non-invariance.
\code{"profile"} and \code{"uniroot"} avoid these issues but are much
slower, requiring estimation of restricted models. Of the two,
\code{"uniroot"} is typically less robust.
}
