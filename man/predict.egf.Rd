% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.egf}
\alias{predict.egf}
\title{Compute predicted values}
\usage{
\method{predict}{egf}(
  object,
  what = c("log_int_inc", "log_cum_inc", "log_rt"),
  time,
  window,
  append = NULL,
  log = TRUE,
  se = FALSE,
  .append = NULL,
  ...
)
}
\arguments{
\item{object}{An \code{"egf"} object returned by \code{\link[=egf]{egf()}}.}

\item{what}{A character vector listing one or more variables for which
predicted values are desired.}

\item{time}{A numeric or Date vector supplying time points at which
predicted values are sought. Numeric \code{time} is assumed
to measure time as a number of days since the end of date
\code{origin = attr(object$frame_ts, "origin")}. Date \code{time}
is coerced to numeric \code{julian(time, origin)}. When missing,
\code{object$frame_ts$time} is used.}

\item{window}{A factor of length \code{length(time)} such that \code{split(time, window)}
splits \code{time} by fitting window. Levels not belonging to
\code{levels(object$frame_ts$window)} are ignored. When \code{time}
is missing, \code{object$frame_ts$window} is used.}

\item{append}{An expression indicating variables in the combined model frame
to be included with the result. The default (\code{NULL}) is to append
nothing.}

\item{log}{A logical scalar. If \code{FALSE}, then inverse log-transformed
predicted values are returned.}

\item{se}{A logical scalar. If \code{log = TRUE} and \code{se = TRUE}, then
approximate (delta method) standard errors on predicted values
are reported. Note that standard errors are required for
subsequent use of \code{\link[=confint.egf_predict]{confint.egf_predict()}}.}

\item{.append}{A character vector listing variable names, to be used
(if non-\code{NULL}) in place of the result of evaluating \code{append}.}

\item{...}{Unused optional arguments.}
}
\value{
A data frame inheriting from class \code{"egf_predict"}, with variables:
\item{\code{var}}{
Predicted variable, from \code{what}.
}
\item{\code{ts}}{
Time series, from \code{levels(object$endpoints$ts)}.
}
\item{\code{window}}{
Fitting window, from \code{levels(object$endpoints$window)}.
}
\item{\code{time}}{
Time, after possible coercion from Date to numeric.
}
\item{\code{estimate}}{
Predicted value of \code{var} "at" \code{time} in \code{window} (see Details),
conditional on \code{object$frame_par} and \code{object$best}.
}
\item{\code{se}}{
(If \code{log = TRUE} and \code{se = TRUE}.)
Approximate (delta method) standard error on \code{estimate}.
}
\code{attr(object$endpoints, "origin")} is retained as an attribute.
}
\description{
Computes predicted values of interval incidence,
cumulative incidence, and the per capita growth rate
conditional on observed data and an estimated model.
}
\details{
In the returned data frame, assuming \code{log = FALSE},
\code{estimate[i]} can be interpreted as follows:
\describe{
\item{\code{int_inc}}{
The number of cases predicted from \code{time[i-1]} to \code{time[i]}
in \code{window[i]} (interval incidence).
}
\item{\code{cum_inc}}{
The number of cases predicted from the start of \code{window[i]}
to \code{time[i]} (cumulative incidence).
}
\item{\code{rt}}{
The per capita growth rate at \code{time[i]}. This is obtained
exactly from the differential equation model associated with
\code{object$curve}, unless \code{object$weekday > 0}, in which case
it is approximated by 7-point local linear regression of the
log interval incidence time series.
}
}
}
