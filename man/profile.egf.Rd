% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/profile.R
\name{profile.egf}
\alias{profile.egf}
\title{Compute likelihood profiles}
\usage{
\method{profile}{egf}(
  fitted,
  which = NULL,
  A = NULL,
  par = get_par_names(fitted, link = TRUE),
  subset = NULL,
  append = NULL,
  max_level = 0.99,
  grid_len = 12,
  trace = TRUE,
  parallel = c("serial", "multicore", "snow"),
  cores = getOption("egf.cores", 2L),
  outfile = NULL,
  cl = NULL,
  .subset = NULL,
  .append = NULL,
  ...
)
}
\arguments{
\item{fitted}{An \code{"egf"} object returned by \code{\link[=egf]{egf()}}.}

\item{which}{An integer vector indexing coefficients in \code{fitted$best}
to be profiled. Must be a subset of \code{fitted$nonrandom}.}

\item{A}{A numeric matrix with \code{length(fitted$nonrandom)} columns.
Each row specifies a linear combination of the elements of
\code{fitted$best[fitted$nonrandom]} to be profiled. Ignored if
\code{which} is non-\code{NULL}.}

\item{par}{A subset of \code{get_par_names(fitted, link = TRUE)} naming nonlinear
model parameters whose population fitted values should be profiled.
Ignored if \code{which} or \code{A} is non-\code{NULL}.}

\item{subset}{An expression to be evaluated in the combined model frame
(see \code{\link[=make_combined]{make_combined()}}). Must evaluate to a logical vector
indexing rows of the data frame, and thus fitting windows.
Only population fitted values for indexed windows are profiled.
The default (\code{NULL}) is to consider all windows. Ignored if
\code{which} or \code{A} is non-\code{NULL}.}

\item{append}{An expression indicating variables in the combined model frame
(see \code{\link[=make_combined]{make_combined()}}) to be included with the result.
The default (\code{NULL}) is to append nothing.
Ignored if \code{which} or \code{A} is non-\code{NULL}.}

\item{max_level}{A number in the interval (0,1). Profiles will be computed
up to a deviance of \code{qchisq(max_level, df = 1)}.}

\item{grid_len}{A positive integer. Step sizes chosen adaptively by
\code{\link[TMB:tmbprofile]{TMB::tmbprofile()}} will generate approximately this
many points on each side of a profile's minimum point.}

\item{trace}{A logical scalar. If \code{TRUE}, then basic tracing messages
are printed.}

\item{parallel}{A character string indicating a library for parallel computation.
\code{"serial"} indicates no parallelization. \code{"multicore"} forks and
is intended for use from a terminal rather than, e.g., RStudio.
On Windows, it is equivalent to \code{"serial"}. \code{"snow"} creates
socket clusters and parallelizes on both Unix-alikes and Windows.}

\item{cores}{A positive integer. The number of worker processes spawned when
\code{parallel != "serial"}. See also \code{\link[parallel:detectCores]{parallel::detectCores()}}.}

\item{outfile}{A character string containing a file path or otherwise \code{NULL}.
If a file path, then console output is diverted there. If \code{NULL},
then there is no diversion. When \code{parallel = "snow"}, diversion
may be necessary to view output.}

\item{cl}{A optional socket cluster created by
\code{\link[parallel:makeCluster]{parallel::makePSOCKcluster()}}, to be used
when \code{parallel = "snow"}. If non-\code{NULL},
then \code{cores} and \code{outfile} are ignored.}

\item{.subset}{A logical vector, to be used (if non-\code{NULL}) in place
of the result of evaluating \code{subset}.}

\item{.append}{A character vector listing variable names, to be used
(if non-\code{NULL}) in place of the result of evaluating \code{append}.}

\item{...}{Unused optional arguments.}
}
\value{
A data frame inheriting from class \code{"egf_profile"}, with variables:
\item{\code{par}}{
(\code{par}-based calls only.)
Nonlinear model parameter,
from \code{get_par_names(fitted, link = TRUE)}.
}
\item{\code{ts}}{
(\code{par}-based calls only.)
Time series, from \code{levels(fitted$endpoints$ts)}.
}
\item{\code{window}}{
(\code{par}-based calls only.)
Fitting window, from \code{levels(fitted$endpoints$window)}.
}
\item{\code{linear_combination}}{
Row index of linear combination, from \code{seq_len(nrow(A))}.
}
\item{\code{value}}{
Value of linear combination being profiled.
}
\item{\code{deviance}}{
Deviance of the restricted model that assumes \code{value}
for the linear combination being profiled.
}
\code{A} and \code{x = fitted$best[fitted$nonrandom]}
are retained as attributes.
}
\description{
Computes the univariate likelihood profile of fixed effects
coefficients, log standard deviations of random effects
coefficients, and linear combinations thereof.
}
\details{
The population fitted value is the fixed effects component of
the individual fitted value (see \code{\link[=fitted.egf]{fitted.egf()}}).
In fixed effects models, there is no distinction.

\code{which} is mapped to an \code{A} matrix composed of unit row vectors,
with 1 at array index \verb{[i, which[i]]} for all \code{i}.
\code{A \%*\% fitted$best[fitted$nonrandom]} is precisely
\code{fitted$best[which]}.

\code{par} and \code{subset} are mapped to a block \code{A} matrix. Block \code{k}
(from the top) is composed of rows of the fixed effects design
matrix for parameter \code{par[k]} (those rows indexed by \code{subset}).
\code{A \%*\% fitted$par[fitted$nonrandom]} is a vector listing the
population fitted values for each parameter named in \code{par},
for each fitting window indexed by \code{subset}.

See topic \code{\link{nse}} for details on nonstandard evaluation
of \code{subset} and \code{append}.
}
\seealso{
\code{\link[=confint.egf_profile]{confint.egf_profile()}}, \code{\link[=plot.egf_profile]{plot.egf_profile()}}
}
