% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_formula.R
\name{split_terms}
\alias{split_terms}
\alias{unsplit_terms}
\title{Split and unsplit formula terms}
\usage{
split_terms(x)

unsplit_terms(l)
}
\arguments{
\item{x}{A \link{call} (possibly a \link{formula}), \link{name},
or \link{atomic} scalar.}

\item{l}{A \link{list} of \link{call}s, \link{name}s, and \link{atomic} scalars.}
}
\value{
A \link{list} of \link{call}s, \link{name}s, and \link{atomic} scalars.
}
\description{
Split nested \link{call}s to binary operators \code{`+`}
and \code{`-`} with \code{split_terms}. Perform the inverse
operation with \code{unsplit_terms}.
}
\details{
Semantically extraneous \code{`(`} \link{call}s, as in the
expression \code{(x) + (y)} are stripped when splitting
and not replaced when unsplitting. In these cases,
\code{\link{identical}(x, unsplit_terms(split_terms(x)))}
may return \code{FALSE}.

If \code{x} is a formula, then the right hand side is split.
In this case, \code{unsplit_terms(split_terms(x))} reproduces
\code{x[[\link{length}(x)]]}, not \code{x}.
}
\examples{
# x <- quote(1 + a * b - b + (c | d) + (0 + e | f))
# l <- split_terms(x)
# y <- unsplit_terms(l)
# identical(x, y)
# # [1] FALSE

}
\keyword{internal}
